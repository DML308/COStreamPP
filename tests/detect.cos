#define N 262144
#define W 512
#define H 512

int img[262144];
composite Filter_3x1_gauss(output stream<float u>Out,input stream<int x>In)
{
	Out = filter_3x1_gauss(In)
	{
		work
		{
			int i;
			float x0 = 0,x1 = 0,x2 = 0;
			for(i=0;i<W;i++)
			{
				x0=0;
				x1=0;
				x2=0;
				if(i>=1)
					x0 = In[i-1].x*0.0924;

				x1 = In[i].x*0.1192;

				if(i<W-1)
					x2 = In[i+1].x*0.0924;

				Out[i].u = x0+x1+x2;
			}
		}
		window
		{
			In sliding(W,W);
			Out tumbling(W);
		}
	};
}

composite Filter_1x3_gauss(output stream<float u>Outx,stream<float u>Outy,input stream<float u>In)
{
	(Outx,Outy) = filter_1x3_gauss(In)
	{
		work
		{
			int i,j;
			float x0=0,x1=0,x2=0;

			for(j=0;j<H;j++)
			{
				for(i=0;i<W;i++)
				{
					x0=0;
					x1=0;
					x2=0;
					if(j>=1)
					{
						x0 = In[W*(j-1)+i].u*1;
					}

					x1 = In[W*j+i].u*1.29;

					if(j<=H-2)
					{
						x2 = In[W*(j+1)+i].u*1;
					}

					Outx[W*j+i].u=x0+x1+x2;
					Outy[W*j+i].u=x0+x1+x2;
				}
			}
		}
		window
		{
			In sliding(N,N);
			Outx tumbling(N);
			Outy tumbling(N);
		}
	};
}

composite Filter_3x1_x_sobel(output stream<float u>Out,input stream<float u>In)
{
	Out = filter_3x1_x_sobel(In)
	{
		work
		{
			int i;
			float x0 = 0,x1 = 0,x2 = 0;
			for(i=0;i<W;i++)
			{
				x0=0;
				x1=0;
				x2=0;
				if(i>=1)
					x0 = In[i-1].u*(-1);

				x1 = In[i].u*0;

				if(i<W-1)
					x2 = In[i+1].u*1;

				Out[i].u = x0+x1+x2;
			}
		}
		window
		{
			In sliding(W,W);
			Out tumbling(W);
		}
	};
}

composite Filter_1x3_x_sobel(output stream<float u>Out,input stream<float u>In)
{
	Out = filter_1x3_x_sobel(In)
	{
		work
		{
			int i,j;
			float x0=0,x1=0,x2=0;

			for(j=0;j<H;j++)
			{
				for(i=0;i<W;i++)
				{
					x0=0;
					x1=0;
					x2=0;
					if(j>=1)
					{
						x0 = In[W*(j-1)+i].u*1;
					}

					x1 = In[W*j+i].u*2;

					if(j<=H-2)
					{
						x2 = In[W*(j+1)+i].u*1;
					}

					Out[W*j+i].u=x0+x1+x2;
				}
			}
		}
		window
		{
			In sliding(N,N);
			Out tumbling(N);
		}
	};
}

composite Filter_3x1_y_sobel(output stream<float u>Out,input stream<float u>In)
{
	Out = filter_3x1_y_sobel(In)
	{
		work
		{
			int i;
			float x0 = 0,x1 = 0,x2 = 0;
			for(i=0;i<W;i++)
			{
				x0=0;
				x1=0;
				x2=0;
				if(i>=1)
					x0 = In[i-1].u*1;

				x1 = In[i].u*2;

				if(i<W-1)
					x2 = In[i+1].u*1;

				Out[i].u = x0+x1+x2;
			}
		}
		window
		{
			In sliding(W,W);
			Out tumbling(W);
		}
	};	
}

composite Filter_1x3_y_sobel(output stream<float u>Out,input stream<float u>In)
{
	Out = filter_1x3_y_sobel(In)
	{
		work
		{
			int i,j;
			float x0=0,x1=0,x2=0;

			for(j=0;j<H;j++)
			{
				for(i=0;i<W;i++)
				{
					x0=0;
					x1=0;
					x2=0;
					if(j>=1)
					{
						x0 = In[W*(j-1)+i].u*1;
					}

					x1 = In[W*j+i].u*0;

					if(j<=H-2)
					{
						x2 = In[W*(j+1)+i].u*(-1);
					}

					Out[W*j+i].u=x0+x1+x2;
				}
			}
		}
		window
		{
			In sliding(N,N);
			Out tumbling(N);
		}
	};
}

composite Filter_CAL(output stream<float u,float p,float q>Out,input stream<float u>In0,stream<float u>In1)
{
	Out = filter_cal(In0,In1)
	{
		work
		{
			int i;
			for(i = 0;i<N;i++)
			{
				Out[i].u = sqrt(In0[i].u*In0[i].u+In1[i].u*In1[i].u);
				Out[i].p=In0[i].u;
				Out[i].q=In1[i].u;
			}
		}
		window
		{
			In0 sliding(N,N);
			In1 sliding(N,N);
			Out tumbling(N);
		}
	};
}

composite Filter_LocalMaxValue(output stream<float u>Out,input stream<float u,float p,float q>In)
{
	Out = filter_localmaxvalue(In)
	{
		work
		{
			int x,y;
			int nPos;
			int gx,gy;
			int g1,g2,g3,g4;

			double weight;
			double dTemp,dTemp1,dTemp2;

			for(x=0;x<W;x++)
			{
				Out[x].u=0;
				Out[(H-1)*W+x].u=0;
			}
			for(y=0;y<H;y++)
			{
				Out[y*W].u=0;
				Out[y*W+W-1].u=0;
			}

			for (y=1;y<H-1;y++)
			{
				for (x=1;x<W-1;x++)
				{
					nPos=y*W+x;
					// if pMag[nPos]==0, then nPos is not the edge point
					if (In[nPos].u==0)
					{
						Out[nPos].u=0;
					}
					else
					{
						// the gradient of current point
						dTemp=In[nPos].u;
						// x,y 方向导数
						gx=In[nPos].p;
						gy=In[nPos].q;
						//如果方向导数y分量比x分量大，说明导数方向趋向于y分量
						if (abs(gy)>abs(gx))
						{
							// calculate the factor of interplation
							weight=fabs(gx)/fabs(gy);
							g2 = In[nPos-W].u;  // 上一行
		                    g4 = In[nPos+W].u;  // 下一行
							//如果x,y两个方向导数的符号相同
		                    //C 为当前像素，与g1-g4 的位置关系为：
		                    //g1 g2
		                    //   C
		                    //   g4 g3
							if(gx*gy>0)
		                    {
		                        g1 = In[nPos-W-1].u;
		                        g3 = In[nPos+W+1].u;
		                    }					
		                    //如果x,y两个方向的方向导数方向相反
		                    //C是当前像素，与g1-g4的关系为：
		                    //    g2 g1
		                    //    C
		                    // g3 g4
		                    else
		                    {
		                        g1 = In[nPos-W+1].u;
		                        g3 = In[nPos+W-1].u;
		                    }
						}
						else
						{
							//插值比例
		                    weight = fabs(gy)/fabs(gx);					
		                    g2 = In[nPos+1].u; //后一列
		                    g4 = In[nPos-1].u; // 前一列				
		                    //如果x,y两个方向的方向导数符号相同
		                    //当前像素C与 g1-g4的关系为
		                    // g3
		                    // g4 C g2
		                    //       g1
							if(gx * gy > 0)
		                    {
		                        g1 = In[nPos+W+1].u;
		                        g3 = In[nPos-W-1].u;
		                    }
							
		                    //如果x,y两个方向导数的方向相反
		                    // C与g1-g4的关系为
		                    // g1
		                    // g4 C g2
		                    //      g3
		                    else
		                    {
		                        g1 = In[nPos-W+1].u;
		                        g3 = In[nPos+W-1].u;
		                    }
						}
						
						dTemp1 = weight*g1 + (1-weight)*g2;
						dTemp2 = weight*g3 + (1-weight)*g4;				
						//当前像素的梯度是局部的最大值
						//该点可能是边界点
						if(dTemp>=dTemp1 && dTemp>=dTemp2)
						{
							Out[nPos].u = In[nPos].u;
						}
						else
						{
							//不可能是边界点
							Out[nPos].u = 0;
						}			
					}
				}
			}

		}
		window
		{
			In sliding(N,N);
			Out tumbling(N);
		}
	};
}

composite Filter_Boundary(output stream<float u>Out,input stream<float u>In)
{
	Out = filter_boundary(In)
	{
		work
		{
			int i;
			for(i = 0;i<N;i++)
			{
				if(In[i].u>150)
					Out[i].u=255;
				else if(In[i].u>50)
					Out[i].u=In[i].u;
				else
					Out[i].u=0;
			}
		}
		window
		{
			In sliding(N,N);
			Out tumbling(N);
		}
	};
}

composite Main()
{
	stream<int x> Source;
	stream<float u> S1,SX,SY,X1,X2,Y1,Y2,LocalMax;
	stream<float u,float p,float q> CAL;
	stream<float u> result;

	Source = SourceReader()
	{
		work
		{

		}
		window
		{
			Source tumbling(N);
		}
	};

	S1 = Filter_3x1_gauss(Source)();
	(SX,SY) = Filter_1x3_gauss(S1)();
	X1 = Filter_3x1_x_sobel(SX)();
	X2 = Filter_1x3_x_sobel(X1)();
	Y1 = Filter_3x1_y_sobel(SY)();
	Y2 = Filter_1x3_y_sobel(Y1)();
	CAL = Filter_CAL(X2,Y2)();
	LocalMax = Filter_LocalMaxValue(CAL)();
	result = Filter_Boundary(LocalMax)();


	Sink(result)
	{
		work
		{
			println(result[0].u);
		}
	};
}