工作量估计策略:

## init 初态调度只计算init部分工作量

## statement_list 稳态调度需要计算statment_list和work函数的工作量
### declareNode
- 若未赋初值则加`MEMORY_OP`
- 若赋常数初值也加`MEMORY_OP`
- 若赋初值且是给数组赋初值 
    - 若数组的每一维度确定,例如 a[10][10][10],则工作量为`30*MEMORY_OP` **FIXME**
    - 若数组第一维不确定,例如 a[][10],则根据初始化时的参数来定 **总之就是很不准FIXME**

## work 稳态调度需要计算statment_list和work函数的工作量
### work
对 work 对应的`BlockNode`的`stmt_list`进行遍历工作量估计
- `If || IfElse` 先对两个分支的工作量进行估计, 再取平均值, 还要额外加上`If`的固有工作量 **FIXED`work += (newWork - oldWork) / 2`表现和预期不一致,修复为`work -= (newWork - oldWork) / 2`** 
- `Binop`语句的工作量
    - `=`赋值语句为0
    - `.`运算符则取左边表达式的工作量
    - `其它运算符[+-*/%]`, 暂时只识别了右子树的工作量(浮点:`+FLOAT_ARITH_OP`,整形:`+INT_ARITH_OP`**FIXME**
- 